# 第1章 整洁代码
## 1.2 糟糕的代码
勒布朗法则： 稍后等于永不（Later equals never）

### 1.3.5 什么是整洁代码
破窗理论：窗户破损了的建筑让人觉得似乎无人照管。于是别人也再不关心。他们放任窗户继续破损。最终自己也参加破坏活动，在外墙上涂鸦，任垃圾堆积。一扇破损的窗户开辟了大厦走向倾颓的道路。

整洁的代码只做好一件事。

整洁的代码简单直接。不隐藏设计者的意图，充满干净利落的抽象和直截了当的控制语句。

代码越小块越好。

代码应在字面上表达其含义，应当用人类可读的方式来写代码。

## 1.6 童子军军规
借用美国童子军一条简单的军规：让营地比你来时更干净。

如果每次签入时，代码都比签出时干净，那么代码就不会腐坏。

# 第2章 有意义的命名
## 2.2 名副其实
变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。

我们应该选择指明了计量对象和计量单位的名称。

## 2.3 避免误导
程序员必须避免留下掩藏代码本意的错误线索。
提防使用不同之处较小的名称。

误导性真正可怕的例子，是用小写字母l和大写字母O作为变量名。它们看起来完全像是常量“壹”和“零”；

## 2.4 做有意义的区分
如果名称不同，那其意思也应该不同才对。

废话都是冗余的。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。

要区分名称，就要以读者能鉴别不同之处的方式来区分。

## 2.5 使用读得出来的名称

## 2.6 使用可搜索的名称

单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。单字母名称仅用于短方法中的本地变量。

长名称胜于短名称。

## 2.7 避免使用编码（避免在命名中提现类型和作用域）
### 2.7.1 匈牙利语标记法
### 2.7.2 成员前缀
### 2.7.3 接口和实现
如果接口和实现必须选一个来编码的话，建议选择实现。

## 2.8 避免思维映射
不应当让读者在脑中把你的名称翻译为他们熟知的名称。

## 2.9 类名
类名和对象名应该是名词或者动词短语。

重载构造器时，使用描述了参数的静态工厂方法名。可以考虑将相应的构造器设置为private，强制使用这种命名手段。

## 2.10 方法名

# 第3章 函数
## 3.1 短小
函数应该短小

函数的缩进层级不该多于一层或两层。

## 3.2 只做一件事
要判断函数是否不止做了一件事，还有一个方法，就是看是否能再拆出一个函数。

如果一个函数被切分为多个区段，是函数做事太多的明显征兆。只做一件事的函数无法被合理地切分为多个区段。

## 3.3 每个函数一个抽象层级
要确保函数只做一件事，函数中的语句都要在同一抽象层级上。

## 3.4 switch语句
switch语句的问题：1、不止做了一件事。违反了单一权责原则。2、违反了开放闭合原则。每当添加新类型时，就必须修改它。

## 3.5 使用描述性的名称


## 3.6 函数参数
最理想的参数数量是零，其次是一，再次是二，应尽量避免三。

多个参数使测试变得困难。如果参数多于两个，测试覆盖所有可能值的组合会异常困难。

避免输出参数。读函数时，我们惯于认为信息通过参数输入函数，通过返回值从函数中输出。我们不太期望信息通过参数输出。

### 3.6.1 一元函数的普遍形式

### 3.6.2 标识参数
标识参数丑陋不堪。拆分为两个函数来解决。

### 3.6.3 二元函数

## 3.9 使用异常替代返回错误码
从指令式函数返回错误码轻微违反了指令与询问分隔的规则。可能导致深层次的嵌套结构。

如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来。


### 3.9.1 抽离try/catch代码块

try/catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try和catch代码块的主题部分抽离出来，另外形成函数。

### 3.9.2 错误处理就是一件事
函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。这意味着如果关键字try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finally代码块后面也不该有其他内容。


### 3.9.3 Error.java依赖磁铁
使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。

## 3.10 别重复自己
重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。



# 第4章 注释
“别给糟糕的代码加注释——重新写吧”

## 4.1 注释不能美化糟糕的代码
带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样得多。与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那对糟糕的代码。


## 4.2 用代码来阐述

## 4.3 好注释

## 4.4 坏注释
大多数注释都属此类。通常，坏注释都是糟糕的代码的支撑或借口，或者对错误决策的修正，基本上等于程序员自说自话。

### 4.4.1 喃喃自语
如果你决定写注释，就要花必要的时间确保写出最好的注释。

### 4.4.2 多余的注释

### 4.4.4 循规式注释
所谓每个函数都要有Javadoc或每个变量都要有注释的规矩全然是愚蠢可笑的。

### 4.4.5 日志式注释
有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。

### 4.4.12 注释掉的代码
直接把代码注释掉是讨厌的做法。别这么干。


# 第5章 格式

# 第6章 对象和数据结构

## 6.1 数据抽象

## 6.3 迪米特法则
迪米特法则：一个对象应当对其他对象有尽可能少的了解。

### 6.3.2 混杂

### 6.3.3 隐藏结构

# 第7章 错误处理
错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。

## 7.1 使用异常而非返回码
返回码的问题在于，它们搞乱了调用者代码。调用者必须在调用之后即刻检查错误。不幸的是，这个步骤很容易被遗忘。所以，遇到错误时，最好抛出一个异常。

## 7.2 先写try-catch-finally语句

## 7.3 使用不可控异常

代价是什么？可控异常的代价就是违反开放/闭合原则。如果你在方法中抛出可控异常，而catch语句在三个层级之上，你就得在catch语句和抛出异常处之间的每个方法签名中。

如果你在编写一套关键代码库，则可控异常有时也会有用：你必须捕获异常。但对于一般的应用开发，其依赖成本要高于收益。

## 7.4 给出异常发生的环境说明
应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给catch块，并记录下来。

## 7.5 依调用者需要定义异常类

## 7.6 定义常规流程

## 7.7 别返回null值
如果你打算在方法中返回null值，不如抛出异常，或是返回特例对象。如果你在调用某个第三方API中可能返回null值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或返回特例对象。

## 7.8 别传递null值
在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值。事已如此，恰当的做法就是禁止传入null值。

## 8.1 使用第三方代码
我们建议不要将Map（或在边界上的其他接口）在系统中传递。如果你使用类似map这样的边界接口，就把它保留在类或近亲类中。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。

## 8.2 浏览和学习边界
缺页了..

## 8.4 学习性测试的好处不只是免费

## 8.5 使用尚不存在的代码


# 第9章 单元测试

## 9.1 TDD三定律
TDD三定律
- 定律一 在编写不能通过的单元测试前，不可编写生产代码。
- 定律二 只可编写刚好无法通过的单元测试，不能编译也算不通过。
- 定律三 只可编写刚好足以通过当前失败测试的生产代码。

## 9.2 保持测试整洁


## 9.5 F.I.R.S.T
整洁的测试遵循以下5条规则
- 快速（Fast）测试应该能快速运行。
- 独立（Independent）测试应该相互独立。
- 可重复（Repeatable）测试应当可在任何环境中重复通过。
- 自足验证（self-validating）测试应该由布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。
- 即使（Timely）测试应及时编写。


# 第10章 类
## 10.1 类的组织

## 10.2 类应该短小
对于函数，我们通过计算代码函数衡量大小。对于类，我们采用不同的衡量方法，计算权责。

类的名字应当描述其权责。类名越含混，该类越有可能拥有过多权责。例如，如果类名中包括含义模糊的词，如Processor或Manager或Super，这种现象往往说明有不恰当的权责聚集情况存在。

### 10.2.1 单一权责原则
单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。类只应该有一个权责——只有一条修改的理由。

系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。


### 10.2.2 内聚
内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。


### 10.2.3 保持内聚性就会得到许多短小的类


# 第11章 系统

# 第17章 味道与启发
## 17.1 注释
**不恰当的信息。** 通常，作者、最后修改时间、SPR数等元数据不该在注释中出现。注释只应该描述有关代码和设计的技术性信息。

**废弃的注释。**过时、无关或不正确的注释就是废弃的注释。

**冗余注释。**注释应该谈及代码自身没提到的东西。

**糟糕的注释。**如果要编写一条注释，就花时间保证写出最好的注释。字斟句酌。

**注释掉的代码。**
## 17.2 环境
 **需要多步才能实现的构建。**

 **需要多步才能做到的测试。**

## 17.3 函数
**过多的参数。**

**输出参数。**输出参数违反直觉。读者期望参数用于输入而非输出。

**标识参数。**布尔值参数大声宣告函数做了不止一件事。

**死函数。**永不被调用的方法应该丢弃。

## 17.4 一般性问题
**一个源文件中存在多种语言。**

**明显的行为未被实现。**遵循“最小惊异原则”，函数或类应该实现其他程序员有理由期待的行为。

**不正确的边界行为。**

**忽视安全。**

**重复。**

**在错误的抽象层级上的代码。**

**基类依赖于派生类**

**信息过多。**设计良好的模块有着非常小的接口，让你能事半功倍。设计低劣的模块有着广阔、深入的接口，你不得不事倍功半。优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。

**死代码**

**垂直分隔。**变量和函数应该在靠近被使用的地方定义。本地变量应该正好在首次被使用的位置上声明，垂直距离要短。

**前后不一致。**

**混淆视听。**

**人为耦合。**人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量、常量或函数不恰当地放在临时方便的位置。花点时间研究应该在什么地方声明函数、常量和变量。不要为了方便随手放置，然后置之不理。

**特性依恋。**

**选择算子参数。**选择算子参数只是一种避免把搭函数切分为多个小函数的偷懒做法。

**晦涩的意图。** 代码要尽可能具有表达力。联排表达式、匈牙利语标记法和魔术数都遮蔽了作者的意图。

**位置错误的权责。**

**不恰当的静态方法。**

**应使用解释性变量。** 让程序可读的最有力方法之一就是将计算过程打散成在用有意义的单词命名的变量中放置的中间值。

**函数名称应该表达其行为。**如果你必须查看函数的实现才知道它是做什么的，就应该换个更好的函数名，或者重新安排功能代码，放到有较好名称的函数中。

**理解算法。**

**把逻辑依赖改为物理依赖。** 如果某个模块依赖于另一个模块，依赖就该是物理上的而不是逻辑上的。依赖着模块不应对被依赖者模块有假定（换言之，逻辑依赖）。它应当明确地询问后者全部信息。

**用多态替代if/else或switch/case。**

**遵循标准约定。**

**用命名常量替代魔术数。**术语“魔术数”不仅说数字。它泛指任何不能自我描述的符号。

**准确。**

**结构甚于约定。**

**封装条件。** 如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。

**避免否定性条件。** 

**函数只该做一件事。**

**不应掩蔽时序耦合。**常常有必要使用时序耦合，但你不应该掩蔽它。排列函数参数，好让它们被调用的次序显而易见。

**别随意。**

**封装边界条件。**

**函数应该只在一个抽象层级上。**

**在较高层级放置可配置数据。**

**避免传递浏览。** 传递浏览是指类似a.getB().getC().doSomething()的代码。正确的做法是让直接协作者提供所需的全部服务。不必逛遍系统的对象全图，搜寻我们要调用的方法。

## 17.5 Java
**通过使用通配符避免过长的导入清单。**

**不要继承常量。**

**常量 vs. 枚举。**

## 17.6 名称

**采用描述性名称。**

**名称应与抽象层级相符。**

**尽可能使用标准命名法。**

**无歧义的名称。**

**为较大作用范围选用较长名称。**名称的长度应与作用范围的广泛度相关。对于较小的作用范围，可以用很短的名称，而对于较大作用范围就该用较长的名称。

**避免编码。**不应在名称中包括类型或作用范围信息。

**名称应该说明副作用。**

## 17.7 测试
**测试不足。**

**使用覆盖率工具。**

**别略过小测试。**

**被忽略的测试就是对不确定事物的疑问。**

**测试边界条件**

**全面测试相近的缺陷。**

**测试失败的模式有启发性。**

**测试覆盖率的模式有启发性。**

**测试应该快速。**