# 虚拟机内存区域划分
[原文链接](https://www.cnblogs.com/zhguang/p/3257367.html)
## 程序计数器（Program Counter Register）
- 线程私有区域。
- 指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。
- 如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined
- 只是记录当前指令地址，所以不存在OOM的情况

## 虚拟机栈（JVM Stack）
- 线程私有区域。
- 一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。
- 局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。
- 虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。

## 本地方法栈（Native Method Statck）
- 线程私有
- 本地方法栈与虚拟机栈类似
- 唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的

## 堆区（Heap）
- 堆区由所有线程共享
- 堆区是理解Java GC机制最重要的区域。在JVM所管理的内存中，堆区是最大的一块。
- 堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。
- 如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。

## 方法区（Method Area）
- 各个线程共享的区域
- 用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等
- 在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待。
-之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。
- 一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这不代表在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。

### 运行时常量池
- 运行时常量池（Runtime Constant Pool）是方法区的一部分
- 用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）
- 运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。

## 直接内存（Direct Memory）
- 直接内存，就是JVM以外的机器内存
- 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。

# 垃圾回收
## 怎么判断对象是否可以回收？
### 判断废弃对象的方法
#### 引用计数法
缺点：无法解决循环引用的情况。
#### 可达性分析算法
当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。
##### 可作为GC Roots的对象（4种）
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
2. 方法区中类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI（即一般说的native方法）引用的对象。

### 判断废弃常量的方法
如果常量池中的某个常量没有被任何引用所引用，则该常量是废弃常量。
### 判断无用的类
1. 该类的所有实例都已经被回收，即java堆中不存在该类的实例对象。
2. 加载该类的类加载器已经被回收。
3. 该类所对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射机制访问该类的方法。

## 垃圾收集算法
### 标记清除算法
- 最基础的收集算法
- 首先标记可回收的对象，然后统一回收所有被标记的对象。
- 缺点：1、效率低。2、清除后产生大量内存碎片

### 复制算法
- 将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。
- 优点：实现简单，运行高效。没有内存碎片。
- 缺点：可使用的内存降为原来一半。
- 大部分虚拟机用复制算法作为新生代收集算法。据IBM统计，新生代中98%的对象是朝生夕死的短生命周期对象，所以不需要将新生代划分为容量大小相等的两部分内存，而是将新生代分为Eden区，Survivor0和Survivor1三部分，其占新生代内存容量默认比例分别为8：1：1，其中s0和s1总有一个区域是空白，只有Eden和其中一个Survivor总共90%的新生代容量用于为新创建的对象分配内存，只有10%的Survivor内存浪费。当新生代内存空间不足需要进行垃圾回收时，仍然存活的对象被复制到空白的Survivor内存区域中，Eden和非空白的Survivor进行标记-清理回收，两个Survivor区域是轮换的。

### 标记-整理算法
- 在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理
- 优点：内存被整理以后不会产生大量内存碎片。
- 缺点：复制算法在对象存活率高的情况下就要执行较多的复制操作，效率将会变低

### 分代收集算法
- 没有新的思想。只是将内存划分为几代，每一代用合适的算法。

### 垃圾收集器（7种）
#### serial收集器
- 特点：单线程收集器
- 收集过程：运行->新生代采用复制算法(单线程、STW)->运行->老年代使用标记整理算法(单线程、STW)->运行
- 适用于client端java程序

#### ParNew
- 新生代收集器、复制算法、多线程。
- 其实是Serial收集器的多线程版本。
- 收集过程：运行->新生代采用复制算法(多线程、STW)->运行

#### Parallel Scavenge收集器
- 新生代收集器、复制算法、多线程。
- 特点是：可以通过参数指定吞吐量和停顿时间。
- 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

#### Serial Old收集器
- 老年代、单线程、“标记整理”算法。
- Serial Old是Serial收集器的老年代版本。

#### Parallel Old收集器
- 老年代、多线程、“标记整理”算法
- Parallel Scavenge收集器的老年代版本。

#### CMS收集器
- 多线程、标记清除算法
- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- 整个过程分为4步
1. 初始标记（STW）；标记GC Roots能直接关联的对象；
2. 并发标记；进行GC Roots Tracing
3. 重新标记（STW）;修正并发标记期间因为用户程序继续运作而导致标记变动的那一部分对象的标记记录。
4. 并发清除
##### 缺点
1. CMS收集器对CPU资源非常敏感。并发阶段占用CPU资源会导致应用程序总吞吐量下降。
2. CMS收集器无法处理浮动垃圾。在并发清理阶段，程序运行的垃圾无法清理。
3. CMS基于“标记清除”算法。清除后会产生大量内存碎片。会导致老年代有很大空间剩余，但无法为大对象分配内存，不得不提前进行Full GC。为解决这个问题，CMS收集器提供了一个参数（默认开启），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间会延长。

#### G1收集器
 G1是一款面向服务端应用的垃圾收集器。

特点：
1. 并行与并发
2. 分代收集
3. 空间整合：整体上基于标记整理算法实现，局部上基于复制算法实现。
4. 可预测的停顿；可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

G1收集器的运作大致可划分为以下几个步骤：
1. 初始标记（STW）；标记GC Roots引用的对象
2. 并发标记；可达性分析。
3. 最终标记（STW）；修正并发标记过程中，产生的记录裱花。可以并行执行
4. 筛选回收；对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划。

## 垃圾收集器搭配关系
![image](../images/垃圾收集器搭配关系.jpg)

## 内存分配与回收策略
### 对象优先在eden分配
### 大对象直接进入老年代
### 长期存活的对象将进入老年代
### 动态对象年龄判定
### 空间分配担保
发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果大于，则此次Minor GC是安全的。如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。

如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

# java类加载机制
[深入理解Java 类加载全过程](https://www.jianshu.com/p/0ff696876f26)

[两道面试题，带你解析Java类加载机制](https://mp.weixin.qq.com/s/YTa0h4FSjqvbKDuGYjHjHw)
## Java类加载机制的七个阶段
当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行java Demo命令的时候，我们其实是启动了JVM虚拟机执行 class字节码文件的内容。而**JVM虚拟机执行 class字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。**
### 加载
下面是对于加载过程最为官方的描述。

加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。

其实加载阶段用一句话来说就是：把代码数据加载到内存中。

### 验证

当JVM加载完Class字节码文件并在方法区创建对应的 Class 对象之后，JVM便会启动对该字节码流的校验，只有符合JVM字节码规范的文件才能被JVM 正确执行。这个校验过程大致可以分为下面几个类型：

**JVM规范校验**。JVM会对字节流进行文件格式校验，判断其是否符合 JVM规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等。

**代码逻辑校验**。JVM会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。

当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。

### 准备（重要）

当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。

内存分配的对象。Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。

例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。
```
public static int factor = 3;
public String website = "www.cnblogs.com/chanshuyi";
```

初始化的类型。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。

例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。
```
public static int sector = 3;
```
但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。
```
public static final int number = 3;
```
之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。

两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final  关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。

### 解析

当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。

其实这个阶段对于我们来说也是几乎透明的，了解一下就好。

### 初始化（重要）

到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当JVM遇到下面5种情况的时候会触发初始化：
1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用 JDK1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

### 使用

当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。

### 卸载

当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。